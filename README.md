Отлично, тогда давай **зафиксируем всё одним цельным README**, без “см. выше”, без фрагментов и недомолвок. Ниже — **полная версия**, которую можно **просто скопировать целиком** в `CUP/README.md` и коммитить. Тон — честный, инженерный, без маркетинга и без иллюзий.

---

```markdown
# CUP — Chebul Acoustic Protocol  
Надёжная передача данных через акустический канал (ggwave)

---

## 1. Общая идея проекта

**CUP (Chebul Acoustic Protocol)** — учебно-исследовательский проект, посвящённый построению
**надёжной передачи цифровых данных через акустический канал**
(динамик → микрофон) в условиях шума и нестабильности.

В качестве физического уровня используется библиотека **ggwave**,
поверх которой реализуется собственный протокол:
кадрирование, контроль целостности, фрагментация сообщений и
надёжная доставка с подтверждениями и повторными передачами.

Проект сознательно **не оптимизируется под максимальную скорость**.
Цель — **гарантированная, воспроизводимая доставка небольших объёмов данных**
в шумном канале.

---

## 2. Мотивация

Акустический канал принципиально ненадёжен:

- высокий уровень фонового шума;
- искажения динамиков и микрофонов;
- автоматическая обработка аудио со стороны ОС (AGC, шумоподавление);
- потери и искажения сигналов.

Подход вида «передать байты напрямую» в таких условиях не работает.
Необходим **многоуровневый протокол**, аналогичный сетевым
(Link / Transport), но адаптированный под звук.

---

## 3. Базовая технология (PHY)

В качестве физического уровня используется **ggwave**:

- модуляция: FSK;
- синхронизация и framing — внутри ggwave;
- коррекция ошибок: Reed–Solomon (встроенная);
- поддержка audible / ultrasonic режимов.

В рамках проекта **DSP не переписывается**.
`ggwave` рассматривается как **чёрный ящик PHY**, поверх которого строится протокол.

Ограничение Python-обёртки:
- `ggwave.encode()` принимает **строку**, поэтому бинарные кадры
  передаются как **base64**.
  Это увеличивает накладные расходы, но делает baseline стабильным.

---

## 4. Архитектура (логическая)

```

Application bytes
↓
Message Fragmentation
↓
Frame (header + CRC32)
↓
Stop-and-Wait ARQ (ACK / timeout / retry)
↓
Base64 wrapper (bytes → str)
↓
ggwave PHY (FSK + RS)

```

---

## 5. Реализованные уровни

### 5.1 Физический уровень (PHY)

- Реализован через ggwave.
- Подтверждено детерминированное поведение:
  `encode("abc") → decode → "abc"` при `protocolId = 0`.

### 5.2 Кадры и контроль целостности

- Фиксированный заголовок кадра.
- CRC32 для обнаружения битых кадров.
- Кадры с ошибкой CRC не принимаются и не подтверждаются.

### 5.3 Фрагментация и сборка

- Сообщение разбивается на несколько DATA-кадров.
- На приёмной стороне кадры собираются обратно по `(msg_id, seq, total)`.

### 5.4 Надёжная доставка (Transport)

- Реализован **Stop-and-Wait ARQ**:
  - DATA → ACK;
  - таймаут ожидания;
  - повторная передача при потере;
  - лимит числа попыток.
- ACK подтверждает конкретный кадр.
- Подтверждено корректное поведение при потерях DATA и ACK.

---

## 6. Структура репозитория

```

CUP/
├── README.md
├── .gitignore
└── scripts/
├── **init**.py
├── baseline_ggwave_file.py     # проверка PHY (encode → decode)
├── ggwave_codec.py             # конвертация PCM / float32
├── packet.py                   # frame header + CRC + fragmentation
├── test_packet_over_phy.py     # один кадр поверх PHY
├── test_fragment_over_phy.py   # фрагментация + сборка
├── arq_stop_and_wait.py        # stop-and-wait ARQ поверх PHY
└── measure_arq.py              # измерения и сетка параметров

````

---

## 7. Требования

- Python 3.x
- Виртуальное окружение (venv)
- Установленный `ggwave` (совместимые wheels)

Проверка:
```bash
python -c "import ggwave; print('ggwave ok')"
````

---

## 8. Запуск и проверка

### 8.1 PHY baseline

```bash
python -m scripts.baseline_ggwave_file
```

Ожидается:

```
SUCCESS: protocolId=0
```

---

### 8.2 Frame поверх PHY

```bash
python -m scripts.test_packet_over_phy
```

Ожидается корректный парсинг payload.

---

### 8.3 Fragmentation / Reassembly

```bash
python -m scripts.test_fragment_over_phy
```

Ожидается:

```
OK
```

---

### 8.4 Stop-and-Wait ARQ

```bash
python -m scripts.arq_stop_and_wait
```

Ожидается:

```
FINAL: OK
```

---

### 8.5 Измерения (baseline)

```bash
python -m scripts.measure_arq
```

Пример baseline-результата
(drop DATA = 25%, ACK = 10%, payload = 130 байт):

* лучший goodput при 100% успехе:
  `max_payload = 32`, `timeout = 0.2` → ~50 B/s
* при увеличении timeout скорость падает, но стабильность сохраняется.

Важно: измерения отражают **стоимость протокола + DSP ggwave**,
а не “чистую скорость канала”.

---

## 9. Ограничения текущей модели

* Ненадёжность моделируется как **drop кадров**.
* Битовые ошибки (corrupt / CRC-fail) пока не моделируются.
* Реальный микрофон/динамик пока не подключён
  (используется синтетический PHY).

---

## 10. Roadmap

Ближайшие шаги:

1. Быстрый протокольный симулятор без DSP
   (для перебора параметров без долгих запусков).
2. Добавление corrupt / CRC-fail для приближения к реальному каналу.
3. Подключение реального акустического канала:

   * TX: воспроизведение;
   * RX: запись + потоковый decode.
4. (Опционально) Sliding window / selective repeat.

---

## 11. Статус проекта

Проект находится в состоянии **рабочего baseline**:

* протокол реализован;
* измерения воспроизводимы;
* архитектура зафиксирована.

Дальнейшие улучшения будут делаться поверх этого baseline.

---

## 12. Лицензия

Учебный проект.
(Лицензия может быть добавлена позже при необходимости.)


